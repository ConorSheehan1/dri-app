== Deployment

Once the test suite passes and the code base has been reviewed and agreed
upon, a branch is created for deployment, in the form release-YY.MM.0.

The release number should be incremented as required.

The assets should be compiled and committed.

Once the assets are committed, a tag is created (tag name can be the
same as the branch name), this tag is then merged
to master for the the deployment scripts to deploy.

=== Steps

These steps will only work if your user is in the merge group and has write access to the master branch.

==== git-flow
  $ git flow release start v2.0.0rc2-YYYY-MM-DD
  $ git checkout release v2.0.0rc2-YYYY-MM-DD
  ... check everything ...
  $ git flow release publish v2.0.0rc2-YYYY-MM-DD # for peer review
  $ git flow release finish v2.0.0rc2-YYYY-MM-DD  # merge with master
  $ git checkout develop
  $ rake assets:clean
  $ git commit -am "clear out assets for development branch"

==== manual
From the develop branch
  $ git tag -l # list current tags
  $ git branch release-YY.MM.0 # increase the version number as required
  $ git checkout release-YY.MM.0 # you should now be on the deploy branch
  $ git log # get current hash and check on the buildbot that it is passing tests in develop branch
  $ git checkout master # switch to master to perform the merge
  $ git pull
  $ git merge --no-ff release-YY.MM.0 # perform the merge
  $ git push
  $ git tag -a YY.MM.0
  $ git push --tags

=== Manually deploying

Pushing to Master will cause the builder to run, but if you need to deploy
manually you can do so on dri-admin. You should log in as you with agent forwarding enabled.

  $ cd /srv/infrastructure/ansible-dri-infrastructure/
  $ ansible-playbook -i inventory/hosts.production site.yml --tags=getfacts,dri_app,dri_app_worker -e "deploy_branch=YY.MM.0"

=== TODO

List of things that should be fixed in deploying

* run db:seed, migrate etc... on only the first rails app host and not everywhere.
* use ansible-vault to encrypt the passwords for the buildbot/dri-admin machine so they are at least not sitting around in plain text.
* breakup roles/playbooks in to Prepare, Configure and Deploy phases, this is so Prepare steps which run rarely and take a long time don't affect the Configure and Deploy steps which are usually pretty quick.
* Encode some git hash into the application so it's visible in the footer when the app is deployed, this way you can verify that the correct version is deployed more clearly and easily.
* Automate the tag and merge to master process.
* Figure out how to do database rollbacks if the db:seed/db:migrate commands roll out the wrong changes.
